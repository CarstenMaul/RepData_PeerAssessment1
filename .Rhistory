cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: function allows to set, get the matrix, setinv and getinv for the
## inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
s <- NULL
## bind functions
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setinv <- function(inverse) s <<- inverse
getinv <- function() s
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve: will caclulate the Inverse of a matrix, will return a cached result if
## it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getinv()
## check if cached result is available
if(!is.null(s)) {
print("using cached data")
message("getting cached data")
return(s)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
print("calculating")
data <- x$get()
s <- solve(data, ...)
x$setinv(s)
s
}
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: function allows to set, get the matrix, setinv and getinv for the
## inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
s <- NULL
## bind functions
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setinv <- function(inverse) s <<- inverse
getinv <- function() s
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## cacheSolve: will caclulate the Inverse of a matrix, will return a cached result if
## it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getinv()
## check if cached result is available
if(!is.null(s)) {
print("using cached data")
message("getting cached data")
return(s)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
print("calculating")
data <- x$get()
s <- solve(data, ...)
x$setinv(s)
return(s)
}
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
cacheSolve(makeCacheMatrix(matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)))
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: this function function allows to set, get the matrix,
##                  setinv and getinv for the inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
inv_matrix <- NULL
## bind functions
set <- function(y) {
x <<- y
inv_matrix <<- NULL
}
get <- function() x
setinv <- function(inverse) inv_matrix <<- inverse
getinv <- function() inv_matrix
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve: this function will caclulate the Inverse of a matrix,
##             will return a cached result if it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv_matrix <- x$getinv()
## check if cached result is available
if(!is.null(inv_matrix)) {
print("using cached data")
message("getting cached data")
return(s)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
print("calculating")
data <- x$get()
s <- solve(data, ...)
x$setinv(inv_matrix)
inv_matrix
}
x = matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: this function function allows to set, get the matrix,
##                  setinv and getinv for the inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
inv_matrix <- NULL
## bind functions
set <- function(y) {
x <<- y
inv_matrix <<- NULL
}
get <- function() x
setinv <- function(inverse) inv_matrix <<- inverse
getinv <- function() inv_matrix
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve: this function will caclulate the Inverse of a matrix,
##             will return a cached result if it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv_matrix <- x$getinv()
## check if cached result is available
if(!is.null(inv_matrix)) {
print("using cached data")
message("getting cached data")
return(inv_matrix)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
print("calculating")
data <- x$get()
s <- solve(data, ...)
x$setinv(inv_matrix)
inv_matrix
}
x = matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: this function function allows to set, get the matrix,
##                  setinv and getinv for the inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
inv_matrix <- NULL
## bind functions
set <- function(y) {
x <<- y
inv_matrix <<- NULL
}
get <- function() x
setinv <- function(inverse) inv_matrix <<- inverse
getinv <- function() inv_matrix
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve: this function will caclulate the Inverse of a matrix,
##             will return a cached result if it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv_matrix <- x$getinv()
## check if cached result is available
if(!is.null(inv_matrix)) {
print("using cached data")
message("getting cached data")
return(inv_matrix)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
print("calculating")
data <- x$get()
inv_matrix <- solve(data, ...)
x$setinv(inv_matrix)
inv_matrix
}
x = matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
## This functions will speed up repeatedly computation of a matrix inversion by
## caching the result of the first computation. All following function calls
## will return the cached result.
## makeCacheMatrix: this function function allows to set, get the matrix,
##                  setinv and getinv for the inversed matrix
makeCacheMatrix <- function(x = matrix()) {
## initialize cache variable if it is not set
inv_matrix <- NULL
## bind functions
set <- function(y) {
x <<- y
inv_matrix <<- NULL
}
get <- function() x
setinv <- function(inverse) inv_matrix <<- inverse
getinv <- function() inv_matrix
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve: this function will caclulate the Inverse of a matrix,
##             will return a cached result if it exists
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv_matrix <- x$getinv()
## check if cached result is available
if(!is.null(inv_matrix)) {
message("getting cached data")
return(inv_matrix)
}
## if no cached result not available, calculate the inverse, cache the result,
## return result
data <- x$get()
inv_matrix <- solve(data, ...)
x$setinv(inv_matrix)
inv_matrix
}
## Test sample run commands
x = matrix(c(1,0.5,0.5,1),nrow = 2,ncol = 2)
m = makeCacheMatrix(x)
m$get()
cacheSolve(m)
cacheSolve(m)
set.seed(1)
rpois(5,2)
rpois(5,2)
rpois(5,2)
?pnorm
?qnorm
?set.seed
?qpois
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
?rbinom
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
set.seed(1)
rpois(5, 2)
library(swirl)
swirl()
1:20
pi:10
15:1
?`?`
?`:`
seq(1,20)
seq(0,10,by=0.5)
seq(5,10,length=30)
my_seq <- seq(5,10,length=30)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq(my_seq)
seq_along(my_seq)
rep(0,times=40)
rep(c(0,1,2),times=10)
rep(c(0,1,2),each=10)
num_vect <- c(0.5,55,-10,6)
tf <- num_vect < 1
tf
num_vect >= 6
my_char <- c("My","name","is")
my_char
paste(my_char, collapse = " ")
c(my_char, "Carsten")
my_name <- c(my_char, "Maul")
my_name
paste(my_name,collapse=" ")
paste("Hello","world",collapse=" ")
paste("Hello","world!",sep=" ")
paste(1:3,c("X","Y","Z",sep="")
;
paste(1:3,c("X","Y","Z"),sep="")
LETTERS
paste(LETTERS, 1:4, sep="-")
x <- c(44,NA,5,NA)
x * 3
y <- rnorm(1000)
z <- rep(NA,1000)
my_data <- sample(c(y,z),100)
is.na(my_data)
my_na <- is.na(my_data)
my_na
my_data == NA
sum(my_na)
my_data
0/0
Inf/Inf
Inf - Inf
x
x[1:10]
x[is.na(x)]
y <- x[!is.na(x)]
x
y
y[y>0]
x[x>0]
x[!is.na(x) & x > 0]
x[c(3,5,7)]
x[0]
x[3000]
x[c(-2,-10)]
x[-c(2,10)]
vect <- c(foo = 11, bar = 2, norf = NA)
vect
names(vect)
vect2 <- c(10,2,NA)
vect2 <- c(10,2,NA)
vect2
vect2<-c(11
)
vect2<-c(11, 2, NA)
names(vect2) <- c("foo", "bar", "norf")
identical(vect,vect2)
vect["bar"]
ect[c("foo", "bar")]
vect[c("foo", "bar")]
install.packages("RODBC")
install.packages("RODBC")
github_token
github_token <-oauth2.0_token(oauth_endpoints("github_jtleek"),myapp)
install.packages("httr")
github_token <-oauth2.0_token(oauth_endpoints("github_jtleek"),myapp)
oauth_endpoints("github_jtleek")
myapp <- oauth_app("github_jtleek",key="3dca496ce716b51b5c59", secret="eb9cc78b4f9544eaf77015ca7fb4b41f308a01a2")
library(httr)
oauth_endpoints("gihub_jtleek")
oauth_endpoints("gihub")
oauth_endpoints("jtleek_repoaccess_api")
github_token <- oauth2.0_token(oauth_endpoints("jtleek_repoaccess_api"),myapp)
install.packages("httpuv")
install.packages("jsonlite")
github_token
github_token <-oauth2.0_token(oauth_endpoints("jtleek_repoaccess_api"),myapp)
github_token <- oauth2.0_token(oauth_endpoints("jtleek_repoaccess_api"), myapp)
library(httr)
library(httpuv)
library(jsonlite)
myapp <- oauth_app("jtleek_repoaccess_api",key="3dca496ce716b51b5c59",secret = "eb9cc78b4f9544eaf77015ca7fb4b41f308a01a2")
github_token <- oauth2.0_token(oauth_endpoints("jtleek_repoaccess_api"), myapp)
myapp <- oauth_app("github",key="3dca496ce716b51b5c59",secret = "eb9cc78b4f9544eaf77015ca7fb4b41f308a01a2")
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
gtoken <- config(token = github_token)
request1 <- GET("https://api.github.com/users/jtleek/repos",config(token=github_token))
myjson <- content(request1)
myjson2 <- jsonlite::fromJSON(toJSON(myjson))
View(myjson2)
stop_for_status(request1)
head(myjson2)
subset(myjson2,name="datasharing")
subset(myjson2,name=="datasharing")
download.file("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06pi)
;
")"
")"
")
"
"
)
!
setwd("/Users/carsten/Documents/Coursera/Data_Science_Specialization/Coursera_Programming/Data_Science_Specialization/05_Reproducible_Research/RepData_PeerAssessment1")
getwd()
list.files(".")
?unz
data <- read.table(unz("activity.zip"),sep = ",")
data <- read.table(unz("activity.zip","activity.csv"),sep = ",")
head(data)
data
summary(data)
?read.table
class(data$v2)
class(data$V2)
class(data$V3)
class(data$V1)
summary(data)data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","string",numeric), header = T)
data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","string",numeric), header = T)
data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","string","numeric"), header = T)
data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","character","numeric"), header = T)
class(data$V1)
head(data)
class(data$steps)
class(data$date)
class(data$interval)
library(lubridate)
data$Date <- dmy(data$date)
data$Date <- dmy(data$Date)
data$date <- dmy(data$date)
head(data)
data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","character","numeric"), header = T)
data$date <- dmy(data$date)
data <- read.table(unz("activity.zip","activity.csv"), sep = ",", na.strings = "NA",colClasses = c("numeric","character","numeric"), header = T)
head(data)
?ymd
data$date <- ymd(data$date)
head(data)
class(data$date)
class(data$date)
install.packages("ggplot2")
library(ggplot2)
?plot
p <- ggplot(data,aes(date,sum(steps)))
print(p)
p <- p + geom_histogram(binwidth = bin, colour="white")
p <- p + geom_histogram(colour="white")
print(p)
p <- ggplot(data,aes(date) + geom_histogram())
p <- ggplot(data,geom_histogram())
p <- ggplot(data,aes(steps) + geom_histogram())
p <- ggplot(data,aes(steps,date) + geom_histogram())
p <- ggplot(data,aes(steps,1) + geom_histogram())
p <- ggplot(data,aes(steps,1))
p <- ggplot(data,aes(steps,date))
p <- p + geom_histogram()
print(p)
p <- ggplot(data,aes(x=date, y=steps))
p <- p + geom_histogram()
print(p)
aggregate(data,date,sum)
aggregate(x=data, by = list(Group.date = data$date, FUN = sum
)
)
aggregate(x=data, by = list(Group.date = data$date), FUN = sum)
aggregate(x=data$steps, by = list(Group.date = data$date), FUN = sum)
data_agg <- aggregate(x=data$steps, by = list(Group.date = data$date), FUN = sum)
p <- ggplot(data_agg, aes(x=Group.data, y=x))
p <- p + geom_histogram()
print(p)
p <- ggplot(data_agg, aes(x=Group.date, y=x))
p <- p + geom_histogram()
print(p)
p <- ggplot(data_agg, aes(x=Group.date))
p <- p + geom_histogram()
print(p)
p <- p + geom_histogram(binwidth=max(x))
p <- p + geom_histogram(binwidth=max(data_agg$x))
print(p)
head(data_agg)
library(scales)
p <- p + scale_y_continuous(...count...
)
p <- ggplot(data_agg, aes(x=Group.date, y=..ncount..))
p <- p + geom_histogram()
print(p)
p <- p + scale_y_continuous(..count..)
p <- p + scale_y_continuous()
print(p)
p <- ggplot(data_agg, aes(x=Group.date))
p <- p + geom_histogram()
p <- p + scale_y_continuous()
print(p)
p <- ggplot(data_agg, aes(x=Group.date, y=))
head(data_agg)
p <- ggplot(data_agg, aes(x=Group.date, y=x))
p <- p + scale_y_continuous()
p <- p + geom_histogram()
print(p)
p <- ggplot(data_agg, aes(x=Group.date, y=x), binwidth=)
p <- ggplot(data_agg, aes(x=Group.date, y=x), binwidth=1)
p <- p + scale_y_continuous()
p <- p + geom_histogram()
print(p)
p <- ggplot(data_agg, aes(x=Group.date, y=x), binwidth=1)
ggplot(data_agg, aes(x=data)) +
stat_bin(binwidth=1) +
scale_x_date(breaks=date_breaks(width="1 day"))
ggplot(data_agg, aes(x=date)) +
stat_bin(binwidth=1) +
scale_x_date(breaks=date_breaks(width="1 day"))
ggplot(data_agg, aes(x=Group.date)) +
stat_bin(binwidth=1) +
scale_x_date(breaks=date_breaks(width="1 day"))
class(data_agg$Group.date)
?ymd
?scale_x_date
ggplot(data_agg, aes(x=Group.date)) +
stat_bin(binwidth=1) +
scale_x_datetime(breaks=date_breaks(width="1 day"))
